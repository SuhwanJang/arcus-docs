<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>arcus-server/ARCUS-Server-Ascii-Protocol/1.11/command-pipelining · ARCUS DOCUMENT</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Command Pipelining"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="arcus-server/ARCUS-Server-Ascii-Protocol/1.11/command-pipelining · ARCUS DOCUMENT"/><meta property="og:type" content="website"/><meta property="og:url" content="https://wwww.jam2in.com/index.html"/><meta property="og:description" content="Command Pipelining"/><meta property="og:image" content="https://wwww.jam2in.com/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://wwww.jam2in.com/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/favicon.ico" alt="ARCUS DOCUMENT"/><h2 class="headerTitleWithLogo">ARCUS DOCUMENT</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"></ul></nav></div></header></div></div><div class="navPusher singleRowMobileNav"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">arcus-server/ARCUS-Server-Ascii-Protocol/1.11/command-pipelining</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="command-pipelining"></a><a href="#command-pipelining" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Command Pipelining</h2>
<p>Command pipelining은
“pipe” 키워드를 통해 여러 collection 명령들을 pipelining하여 cache server에 전달하고,
cache server는 각 명령을 처리한 즉시 그 response를 client로 전달하는 것이 아니라
그 response를 reply queue에 보관해 두었다가, 마지막 명령 처리 후에 reply queue에 보관해 둔 전체 response를
한번에 client로 전달하는 기능이다.
기존에 N 번의 request – response를 전달하던 것에 비해
command pipelining은 한 번의 request stream과 한 번의 response stream을 전달할 수 있게 함으로써
network 비용을 상당히 줄일 수 있으며, 전체 latency를 줄일 수 있는 장점을 가진다.</p>
<p>Command pipelining은 현재 collection 명령들 중 일부에 한해서만 가능하다.
Command pipelining 가능한 명령은 아래와 같으며, 단순 response string을 가지는 명령만 이에 해당된다.
한번에 pipelining이 가능한 최대 명령의 수는 <code>500</code>개로 제한을 두고 있음을 주의하여야 한다.</p>
<ul>
<li>lop 명령들 - lop insert/delete</li>
<li>sop 명령들 - sop insert/delete/exist</li>
<li>mop 명령들 - mop insert/delete/update</li>
<li>bop 명령들 - bop insert/upsert/delete/update/incr/decr</li>
</ul>
<p>Command pipelining 수행 예로,
특정 list의 tail 쪽으로 10개 elements를 추가하고자 한다면,
아래와 같이 lop insert 명령을 연속하여 cache server로 보내면 된다.
첫 번째 명령부터 마지막 바로 이전 명령까지는 모두 “pipe” 인자를 사용하여 연결하여야 하고,
마지막 명령에서는 “pipe” 인자를 생략함으로써 pipelining의 끝임을 표현하여야 한다.</p>
<pre><code class="hljs"> lop insert lkey -1 6 pipe<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>datum0<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>
 lop insert lkey -1 6 pipe<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>datum1<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>
 lop insert lkey -1 6 pipe<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>datum2<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>
 lop insert lkey -1 6 pipe<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>datum3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>
 lop insert lkey -1 6 pipe<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>datum4<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>
 lop insert lkey -1 6 pipe<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>datum5<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>
 lop insert lkey -1 6 pipe<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>datum6<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>
 lop insert lkey -1 6 pipe<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>datum7<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>
 lop insert lkey -1 6 pipe<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>datum8<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>
 lop insert lkey -1 6<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>datum9<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>
</code></pre>
<p>Command pipelining의 response string은 아래와 같다.</p>
<pre><code class="hljs">RESPONSE &lt;count&gt;\r\n
&lt;STATUS <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-number">1</span>st pipelined <span class="hljs-keyword">command</span>&gt;\<span class="hljs-title">r</span>\<span class="hljs-title">n</span>
&lt;STATUS <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-number">2</span>nd pipelined <span class="hljs-keyword">command</span>&gt;\<span class="hljs-title">r</span>\<span class="hljs-title">n</span>
...
&lt;STATUS <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> pipelined <span class="hljs-keyword">command</span>&gt;\<span class="hljs-title">r</span>\<span class="hljs-title">n</span>
END|PIPE_ERROR &lt;error_string&gt;\r\n
</code></pre>
<p>RESPONSE 라인에서 &lt;count&gt;는 전체 결과 수를 나타내고,
그 다음 라인들은 각 명령의 수행 결과를 차례로 나타낸다.
각 명령의 결과는 각 명령마다 다르므로 각 명령에 대한 설명을 참조하여야 한다.
마지막 라인은 pipelining 수행 상태를 나타내며, 아래 중의 하나를 가진다.</p>
<ul>
<li>&quot;END&quot; - pipelining 연산이 정상 수행됨</li>
<li>“PIPE_ERROR command overflow” - pipelining 가능한 최대 commands 수인 500개를 초과하였다.
이 경우, 500개까지의 command들만 하나의 command pipelining으로 처리되고 하나의 response stream으로 리턴된다.
그 이후의 commands들은 처리되지 않는다.</li>
<li>“PIPE_ERROR memory overflow” - Arcus cache server 내부에서 pipelining 처리를 위한
메모리 공간이 부족한 상태를 의미한다. Arcus cache server는 500개 commands의 result를 담아둘 공간을
미리 확보하여 수행하므로 이 오류가 발생할 가능성은 거의 없다.
단, 의도하지 않은 이유에 의한 경우를 대비하여 이 오류를 추가해 둔 것이다.
이 오류가 발생하면, 그 시점에 command pipelining을 중지하고 그 즉시 response stream을 client에 전달한다.
이 경우의 response stream에는 가장 마지막에 수행된 command의 response string이 생략된다.
그리고, 그 이후의 commands들은 처리되지 않는다.</li>
<li>“PIPE_ERROR bad error” - pipelining 으로 어떤 command를 수행 중
“CLIENT_ERROR”와 “SERVER_ERROR”로 시작하는 중요 오류가 발생한 경우이다.
이 경우에도, 그 즉시 command pipelining을 중지하고 현재까지의 response stream을 client에 전달한다.
그리고, 그 이후의 commands들은 처리되지 않는다.</li>
</ul>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#command-pipelining">Command Pipelining</a></li></ul></nav></div></div></body></html>