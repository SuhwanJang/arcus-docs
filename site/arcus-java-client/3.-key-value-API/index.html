<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>3. key value API - ARCUS Documentation</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <link href="../../custom/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "3-1. Key-Value Item \uc800\uc7a5", url: "#_top", children: [
          ]},
          {title: "3-2. Key-Value Item \uc870\ud68c", url: "#3-2-key-value-item", children: [
          ]},
          {title: "3-3. Key-Value Item \uac12\uc758 \uc99d\uac10", url: "#3-3-key-value-item", children: [
              {title: "Key-Value Item \uc0ad\uc81c", url: "#key-value-item" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    <p>Key-value item은 하나의 key에 대해 하나의 value만을 저장하는 item이다.</p>
<p><strong>제약조건</strong></p>
<ul>
<li>Key의 최대 크기는 250 character이다.</li>
<li>Value는 최대 1Mb까지 저장할 수 있다.</li>
</ul>
<h2 id="3-1-key-value-item">3-1. Key-Value Item 저장</h2>
<p>key-value item을 저장하는 API로 set, add, replace, prepend/append가 있다.</p>
<pre><code class="java">Future&lt;Boolean&gt; set(String key, int exp, Object obj)
Future&lt;Boolean&gt; add(String key, int exp, Object obj)
</code></pre>

<ul>
<li>\&lt;key, obj>의 key-value item을 저장한다.</li>
<li>해당 key가 cache에 이미 존재할 경우,</li>
<li>set은 value 부분만 obj로 변경한다.</li>
<li>add는 \&lt;key, obj> item을 추가하지 않는다.</li>
<li>저장된 key-value item은 exp 초 이후에 삭제된다.</li>
</ul>
<pre><code class="java">Future&lt;Boolean&gt; replace(String key, int exp, Object obj)
</code></pre>

<ul>
<li>주어진 key의 value 부분만을 obj로 교체한다. 해당 key가 cache에 존재하지 않으면, 교체 작업은 수행되지 않는다.</li>
<li>교체된 key-value item은 exp 초 이후에 삭제된다.</li>
</ul>
<pre><code class="java">Future&lt;Boolean&gt; prepend(long cas, String key, Object val)
Future&lt;Boolean&gt; append(long cas, String key, Object val)
</code></pre>

<ul>
<li>주어진 key의 value 부분에서 가장 앞쪽(prepend) 또는 가장 뒤쪽(append)에 val을 추가한다.</li>
<li>첫째 인자인 cas는 현재 이용되지 않으므로 임의의 값을 주면 된다.
  초기에 CAS(compare-and-set) 연산으로 수행하기 위한 용도로 필요했던 인자이다.</li>
</ul>
<p>그리고, 한번의 API 호출로 다수의 key-value items을 set하는 bulk API를 제공한다.</p>
<pre><code class="java">Future&lt;Map&lt;String, CollectionOperationStatus&gt;&gt; asyncSetBulk(List&lt;String&gt; key, int exp, Object obj)
Future&lt;Map&lt;String, CollectionOperationStatus&gt;&gt; asyncSetBulk(Map&lt;String, Object&gt; map, int exp)
</code></pre>

<ul>
<li>다수의 key-value item을 한번에 set한다.</li>
<li>전자는 key list의 모든 key에 대해 동일한 obj로 set 연산을 한번에 수행하며, 
  후자는 map에 있는 모든 \&lt;key, obj>에 대해 set 연산을 한번에 수행한다.</li>
<li>저장된 key-value item들은 모두 exp 초 이후에 삭제된다.</li>
</ul>
<p>expiration은 key가 현재 시간부터 expire 될 때까지의 시간(초 단위)을 입력한다.
시간이 30일을 초과하는 경우 expire 될 unix time을 입력한다.
그 외에 expire 되지 않도록 하기 위해 아래 값을 지정할 수 있다.</p>
<ul>
<li>0: key가 expire 되지 않도록 설정한다. 하지만 Arcus cache server의 메모리가 부족한 경우 LRU에 의해 언제든지 삭제될 수 있다.</li>
<li>-1: key를 sticky item으로 만든다. Sticky item은 expire 되지 않으며 LRU에 의해 삭제되지도 않는다.</li>
</ul>
<h2 id="3-2-key-value-item">3-2. Key-Value Item 조회</h2>
<p>하나의 key에 대한 value를 조회하는 API와 
여러 key들의 value들을 한번에 조회하는 bulk API를 제공한다.</p>
<pre><code class="java">Future&lt;Object&gt; asyncGet(String key)
</code></pre>

<ul>
<li>주어진 key에 저장된 value를 반환한다.</li>
</ul>
<pre><code class="java">Future&lt;Map&lt;String,Object&gt;&gt; asyncGetBulk(Collection&lt;String&gt; keys)
Future&lt;Map&lt;String,Object&gt;&gt; asyncGetBulk(String... keys)
</code></pre>

<ul>
<li>다수 key들에 저장된 value를 Map<String, Object> 형태로 반환한다.</li>
<li>다수 key들은 String 유형의 Collection이거나 String 유형의 나열된 key 목록일 수 있다.</li>
</ul>
<h2 id="3-3-key-value-item">3-3. Key-Value Item 값의 증감</h2>
<p>key-value item에서 value 부분의 값을 증가시키거나 감소시키는 연산이다. 
(<strong>[주의] 증감 연산을 사용하려면, 반드시 value 값이 String 유형의 숫자 값이어야 한다.</strong>)</p>
<pre><code class="java">Future&lt;Long&gt; asyncIncr(String key, int by)
Future&lt;Long&gt; asyncDecr(String key, int by)
</code></pre>

<ul>
<li>key에 저장된 정수형 데이터의 값을 by 만큼 증가/감소시킨다.
  key가 cache에 존재하지 않으면 증감연산은 수행되지 않는다.</li>
<li>반환되는 값은 증감 후의 값이다. </li>
</ul>
<pre><code class="java">Future&lt;Long&gt; asyncIncr(String key, int by, long def, int exp)
Future&lt;Long&gt; asyncDecr(String key, int by, long def, int exp)
</code></pre>

<ul>
<li>key에 저장된 정수형 데이터의 값을 by 만큼 증가/감소시킨다.
  key가 cache에 존재하지 않으면 \&lt;key, def> item을 추가하며, exp 초 이후에 삭제된다.</li>
<li>반환되는 값은 증감 후의 값이다.</li>
</ul>
<h3 id="key-value-item">Key-Value Item 삭제</h3>
<pre><code class="java">Future&lt;Boolean&gt; delete(String key)
</code></pre>

<ul>
<li>주어진 key를 가진 item을 cache에서 삭제한다.</li>
</ul>

  <br>
</div>

<footer class="col-md-12 wm-page-content">

</footer>

</body>
</html>